# Changelog

All notable changes to this project will be documented in this file.

The format loosely follows [Keep a Changelog](https://keepachangelog.com/en/1.1.0/)
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

- No unreleased changes yet.

## [0.2.0] - 2025-11-28

### Added

#### Weather Domain Integration & Data Contracts

- Integrated the weather domain model into the frontend, using canonical entities (`CurrentWeather`, `ForecastTimeline`, `WeatherAlert`, `WeatherBundle`, etc.) aligned with the internal domain documentation.
- Implemented an OpenWeather-based weather provider (`OpenWeatherService`) on top of One Call API 3.0, including URL builder, request helpers and mapping from provider JSON into the domain model.
- Normalised units, timestamps and condition codes (`WeatherConditionCode`) so the rest of the app stays provider-agnostic and does not depend on OpenWeather-specific details.
- Added a TTL-based `weatherStore` with bundle fan-out (current, forecast and alerts) and in-flight request deduplication per location key.
- Connected the map interaction to live weather: clicking on a map location now triggers a weather bundle fetch and exposes the result in the Side Panel.

#### Weather Telemetry & Degraded Data Tracking

- Added weather telemetry helpers to track OpenWeather API usage:
  - Request, success and error events including timing and location metadata.
  - Degraded-data events when forecasts or alerts cannot be mapped cleanly to the domain model.
- Wired the telemetry into `OpenWeatherService.fetchWeatherBundle`, so weather-related behaviour is visible in observability tools.

#### Testing

- Added fixtures for OpenWeather One Call responses to drive adapter and service tests.
- Added unit tests for:
  - Mapping current conditions, hourly/daily forecasts and alerts from OpenWeather JSON into domain entities.
  - `OpenWeatherService.fetchWeatherBundle` success and failure modes (config, network, HTTP and contract errors).
- Added store-level tests for the weather store:
  - Bundle caching and TTL behaviour.
  - In-flight request deduplication per location.
  - Error propagation across current/forecast/alerts resources when the bundle fetch fails.
- Added a Side Panel integration test that covers the `map → weatherStore → UI` flow for selected locations.

## [0.1.0] - 2025-11-28

Initial changelog entry.

### Added

#### Product & Domain Framing 

- Defined the product vision and map-centric positioning of Nimbus Atlas.
- Established the core meteorological domain model (locations, snapshots, forecasts, alerts, layers) and provider-agnostic contracts.
- Documented high-level API contracts and integration boundaries for external weather and geocoding providers.

#### UX Flows & Design System Foundations 

- Defined five key user journeys (UJ1–UJ5) around current conditions, exploration, search, layers and error/empty handling.
- Closed the SPA navigation model with the map as the primary surface across desktop, tablet and mobile.
- Established the first version of the design system: color/typography/spacing/radius tokens and a catalog of base UI components (TopBar, SidePanel, LayersPanel, LegendBar, buttons, inputs, feedback components, etc.).
- Captured global UX patterns for loading/empty/error, accessibility, responsive breakpoints and motion fundamentals.

#### Phase 3 – Frontend Skeleton & Map Core (code)

- Created the `nimbus-atlas` frontend project using Vite, React and TypeScript, with basic tooling and scripts for development, build and tests.
- Implemented the App Shell with:
  - A top bar (brand placeholder, global search input, settings/action area).
  - A main map area that fills the viewport.
  - A floating side panel placeholder used as the first “details” surface.
- Introduced a minimal router with:
  - Main map route (`/`).
  - Settings route and a generic Not Found view.
- Implemented the initial Map Core (`MapRoot`) using MapLibre GL JS:
  - Map initialization with a sensible default center and zoom.
  - Pan/zoom interactions handled by the map engine.
  - Click events translated into neutral `onMapClick` callbacks carrying coordinates.
  - A demo marker + “selected location” overlay to prove the map ↔ UI event flow.
- Added basic UI state to:
  - Track the currently selected location from map clicks.
  - Toggle the visibility of the layers panel without remounting the map.
- Wired a simple map layout and overlays:
  - Layer toggle button and panel as floating overlays on top of the map.
  - Coordinates/status overlay showing the last selected location.

### Testing

- Set up Vitest and React Testing Library for unit and component tests.
- Added base tests for:
  - App Shell layout (top bar, map area and side panel rendering).
  - MapRoot mounting and `onMapReady` callback execution.
  - MapRoot click handling via simulated events.

### Internal

- Aligned the frontend repository structure with the architecture and phase documents (features-based layout, map-centric core, minimal state layer), preparing the ground for Phase 4 (Weather Domain Integration & Data Contracts).
